@page "/chat"
@using Microsoft.AspNetCore.SignalR.Client
@using SemanticChatDemo.Models
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>Semantic Chat</PageTitle>

<div class="h-screen flex flex-col bg-gray-50 relative">
    <!-- Header -->
    <div class="bg-white shadow-sm border-b border-gray-200 px-6 py-4 flex-shrink-0">
        <h1 class="text-2xl font-semibold text-gray-900">Semantic Chat Demo</h1>
        <p class="text-sm text-gray-600 mt-1">
            Status:
            <span class="@(_hubConnection?.State == HubConnectionState.Connected ? "text-green-600" : "text-red-600")">
                @(_hubConnection?.State.ToString() ?? "Disconnected")
            </span>
            @if (!string.IsNullOrEmpty(userId))
            {
                <span class="ml-4 text-gray-500">
                    User: <span class="font-mono text-xs">@userId</span>
                </span>
            }
        </p>
    </div>

    <!-- Chat Messages Area -->
    <div class="flex-1 overflow-y-auto p-6 space-y-4 pb-24" id="chat-container">
        @if (messages.Any())
        {
            @foreach (var message in messages)
            {
                <div class="@(message.Role == "user" ? "flex justify-end" : "flex justify-start")">
                    <div class="@(message.Role == "user" ?
                        "bg-blue-500 text-white rounded-lg rounded-br-none px-4 py-2 max-w-xs lg:max-w-md" :
                        message.Role == "system" ?
                        "bg-red-100 text-red-800 rounded-lg px-4 py-2 max-w-xs lg:max-w-md border border-red-200" :
                        "bg-white text-gray-900 rounded-lg rounded-bl-none px-4 py-2 max-w-xs lg:max-w-md shadow-sm border")">
                        <div class="text-sm whitespace-pre-wrap">
                            @message.Content
                            @if (message.IsStreaming && !message.IsComplete)
                            {
                                <span class="inline-block w-2 h-4 bg-gray-400 ml-1 animate-pulse"></span>
                            }
                        </div>
                        <div class="text-xs opacity-70 mt-1 flex justify-between items-center">
                            <span>@message.Timestamp.ToString("HH:mm")</span>
                            @if (message.IsStreaming && !message.IsComplete)
                            {
                                <span class="text-xs text-gray-500">Typing...</span>
                            }
                        </div>
                    </div>
                </div>
            }
        }
        else
        {
            <div class="text-center text-gray-500 py-8">
                <div class="text-lg font-medium">Welcome to Semantic Chat!</div>
                <div class="text-sm mt-2">Start a conversation by typing a message below.</div>
            </div>
        }
    </div>

    <!-- Input Area - Fixed at bottom -->
    <div class="fixed bottom-0 left-64 right-0 bg-white border-t border-gray-200 px-6 py-4 shadow-lg">
        <div class="flex space-x-4">
            <input @bind="messageInput"
                   @bind:event="oninput"
                   @onkeypress="HandleKeyPress"
                   @ref="messageInputRef"
                   placeholder="Type your message..."
                   disabled="@(_hubConnection?.State != HubConnectionState.Connected)"
                   class="flex-1 border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:bg-gray-100 disabled:cursor-not-allowed" />

            <button @onclick="SendMessage"
                    disabled="@(IsConnected == false || string.IsNullOrWhiteSpace(messageInput))"
                    class="bg-blue-500 hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-medium py-2 px-6 rounded-lg transition-colors">
                Send
            </button>
        </div>
    </div>
</div>

@code {
    private HubConnection? _hubConnection;
    private List<ChatMessage> messages = new();
    private string messageInput = string.Empty;
    private ElementReference messageInputRef;
    private string? userId;

    public bool IsConnected =>
        _hubConnection?.State == HubConnectionState.Connected;

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/chathub"))
            .ConfigureLogging(logging =>
            {
                logging.SetMinimumLevel(LogLevel.Information);
            })
            .Build();

        _hubConnection.On<ChatMessage>("ReceiveMessage", (message) =>
        {
            messages.Add(message);
            InvokeAsync(StateHasChanged);
            InvokeAsync(ScrollToBottom);

            // Refocus input after assistant completes (not during streaming)
            if (message.Role == "assistant" && message.IsComplete)
            {
                InvokeAsync(FocusInput);
            }
        });

        _hubConnection.On<StreamingChatMessage>("ReceiveStreamingChunk", (streamingMessage) =>
        {
            HandleStreamingChunk(streamingMessage);
            InvokeAsync(StateHasChanged);
            InvokeAsync(ScrollToBottom);
        });

        _hubConnection.On("HistoryCleared", () =>
        {
            messages.Clear();
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<object>("HistoryInfo", (info) =>
        {
            // Handle history info if needed
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<List<ConversationMessage>>("ExistingMessagesLoaded", (existingMessages) =>
        {
            LoadExistingMessagesIntoUI(existingMessages);
            InvokeAsync(StateHasChanged);
            InvokeAsync(ScrollToBottom);
        });

        try
        {
            await _hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            // Log the error and show a user-friendly message
            var errorMessage = new ChatMessage
            {
                Content = $"Failed to connect to chat service: {ex.Message}",
                Role = "system"
            };
            messages.Add(errorMessage);
            StateHasChanged();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Get or create persistent user ID after the DOM is ready
            try
            {
                userId = await JSRuntime.InvokeAsync<string>("userStorage.getUserId");

                // Load any existing history for this user
                if (_hubConnection?.State == HubConnectionState.Connected && !string.IsNullOrEmpty(userId))
                {
                    await _hubConnection.SendAsync("LoadExistingMessages", userId);
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                // Fallback to a temporary ID if localStorage fails
                userId = $"temp-user-{DateTime.Now.Ticks}";
                var errorMessage = new ChatMessage
                {
                    Content = $"Warning: Could not access browser storage. Using temporary session. {ex.Message}",
                    Role = "system"
                };
                messages.Add(errorMessage);
                StateHasChanged();
            }

            await FocusInput();
        }
    }

    private async Task FocusInput()
    {
        try
        {
            await messageInputRef.FocusAsync();
        }
        catch
        {
            // Ignore focus errors - they can happen during rapid state changes
        }
    }

    private async Task SendMessage()
    {
        if (_hubConnection is not null && !string.IsNullOrWhiteSpace(messageInput) && !string.IsNullOrEmpty(userId))
        {
            await _hubConnection.SendAsync("SendMessage", userId, messageInput);
            messageInput = string.Empty;
            await FocusInput();
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task ClearHistory()
    {
        if (_hubConnection is not null && !string.IsNullOrEmpty(userId))
        {
            await _hubConnection.SendAsync("ClearHistory", userId);
        }
    }

    private void LoadExistingMessagesIntoUI(List<ConversationMessage> existingMessages)
    {
        // Clear current messages and load existing ones
        messages.Clear();
        
        foreach (var msg in existingMessages)
        {
            // Skip empty messages (streaming artifacts)
            if (string.IsNullOrWhiteSpace(msg.Content))
                continue;
                
            // Skip tool messages (function call results)
            if (msg.Role == "tool")
                continue;
                
            messages.Add(new ChatMessage
            {
                Id = msg.Id,
                Content = msg.Content,
                Role = msg.Role,
                Timestamp = msg.Timestamp,
                IsComplete = true,
                IsStreaming = false
            });
        }
    }

    private void HandleStreamingChunk(StreamingChatMessage streamingMessage)
    {
        // Find existing streaming message or create a new one
        var existingMessage = messages.FirstOrDefault(m =>
            m.Id == streamingMessage.MessageId);

        if (existingMessage != null)
        {
            // Update existing streaming message
            existingMessage.Content += streamingMessage.Content;
            existingMessage.IsComplete = streamingMessage.IsComplete;
            existingMessage.IsStreaming = !streamingMessage.IsComplete;
        }
        else
        {
            // Create new streaming message
            var newMessage = new ChatMessage
            {
                Id = streamingMessage.MessageId,
                Content = streamingMessage.Content,
                Role = "assistant",
                Timestamp = DateTime.Now,
                IsStreaming = !streamingMessage.IsComplete,
                IsComplete = streamingMessage.IsComplete
            };
            messages.Add(newMessage);
        }
    }

    private async Task ScrollToBottom()
    {
        await JSRuntime.InvokeVoidAsync("scrollToBottom", "chat-container");
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}

<script>
    window.scrollToBottom = (elementId) => {
        const element = document.getElementById(elementId);
        if (element) {
            element.scrollTop = element.scrollHeight;
        }
    };

    // User storage utilities for managing persistent user identity
    window.userStorage = {
        getUserId: function () {
            const storageKey = 'semantic-chat-userId';
            let userId = localStorage.getItem(storageKey);

            if (!userId) {
                // Generate a simple but unique user ID
                const timestamp = Date.now().toString(36);
                const random = Math.random().toString(36).substring(2, 8);
                userId = `user-${timestamp}-${random}`;

                localStorage.setItem(storageKey, userId);
                console.log('Generated new user ID:', userId);
            } else {
                console.log('Retrieved existing user ID:', userId);
            }

            return userId;
        },

        clearUserId: function () {
            localStorage.removeItem('semantic-chat-userId');
            console.log('Cleared user ID from storage');
        }
    };
</script>
